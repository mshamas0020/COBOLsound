// audio_out.c

// Uses SDL2 to manage and play audio generated by COBOLsound.cbl

#include "SDL2/SDL.h"
#include <stdio.h>

// format globals
static Uint32 BUFFER_SIZE;
static Uint32 SAMPLE_SIZE;
static Uint32 SAMPLE_RATE;

// audio format
static SDL_AudioSpec spec;

// audio device
static SDL_AudioDeviceID device;

// init
// arguments describe audio and buffer format
void audio_init(Uint32* buffSize, Uint32* sampleSize, Uint32* sampleRate) {

    // init SDL
	if (SDL_Init(SDL_INIT_AUDIO) < 0)
		return;

    // make params global
    BUFFER_SIZE = *buffSize;
    SAMPLE_SIZE = *sampleSize;
    SAMPLE_RATE = *sampleRate;

    // 
    SDL_zero(spec);
    spec.freq = SAMPLE_RATE;
    spec.format = AUDIO_S16LSB;
    spec.channels = 1;
    spec.samples = BUFFER_SIZE;
    spec.callback = NULL;
    spec.userdata = NULL;

    device = SDL_OpenAudioDevice(NULL, 0, &spec, NULL, 0);


    if (!device) {
        fprintf(stderr, "Couldn't open audio device: %s\n", SDL_GetError());
	    exit(-1);
	}
}

// start playback
void audio_start_playback() {
	SDL_PauseAudioDevice(device, 0);
    printf("Playback started.\n");
}

// add buffer to queue
// buff* should to raw audio data with the expected buffer/sample size
void audio_queue(void* buff) {
    if (SDL_QueueAudio(device, buff, BUFFER_SIZE * SAMPLE_SIZE)) {
        fprintf(stderr, "Couldn't feed data to stream: %s\n", SDL_GetError());
	    exit(-1);
    }
}

// wait until the audio queue has been exhausted
void audio_wait_for_queue_end() {
    while (SDL_GetQueuedAudioSize(device) > 0) {
        SDL_Delay(100);
    }

    SDL_Delay(1000 * BUFFER_SIZE / SAMPLE_RATE + 10);
}

// end playback and close
void audio_close() {
    SDL_PauseAudioDevice(device, 1);
    SDL_ClearQueuedAudio(device);
	SDL_CloseAudio();

    printf("Playback finished.");
}



// main
int main(int argc, char* argv[]) {}